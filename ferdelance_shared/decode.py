from .generate import SymmetricKey
from .commons import DEFAULT_SEPARATOR

from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey

from base64 import b64decode
from hashlib import sha256

import json
import logging

LOGGER = logging.getLogger(__name__)


def decode_from_transfer(text: str, encoding: str = 'utf8') -> str:
    """Decode the string received through a transfer between client and server.
    :param text:
        Text to decode.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        Decoded bytes.
    """
    in_bytes: bytes = text.encode(encoding)
    b64_bytes: bytes = b64decode(in_bytes)
    out_text: str = b64_bytes.decode(encoding)
    return out_text


def decrypt(private_key: RSAPrivateKey, text: str, encoding: str = 'utf8') -> str:
    """Decrypt a text using a private key.

    :param private_jey:
        Local private key.
    :param text:
        Content to be decrypted.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        The decoded string.
    """
    b64_text: bytes = text.encode(encoding)
    enc_text: bytes = b64decode(b64_text)
    plain_text: bytes = private_key.decrypt(enc_text, padding.PKCS1v15())
    ret_text: str = plain_text.decode(encoding)
    return ret_text


def decrypt_hybrid_key(preamble: bytes, private_key: RSAPrivateKey, encoding='utf8') -> SymmetricKey:
    """Decodes the preamble of a stream, containing the symmetric key for hybrid encryption.

    :param preamble:
        Content read from the stream.
    :param private_key:
        Local private key.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        The SymmetricKey to use.
    """

    preamble_bytes: bytes = private_key.decrypt(preamble, padding.PKCS1v15())
    preamble_str: str = preamble_bytes.decode('utf8')

    decoded: dict = json.loads(preamble_str)

    return SymmetricKey(
        b64decode(decoded['key'].encode(encoding)),
        b64decode(decoded['iv'].encode(encoding)),
    )


def decrypt_stream(reader_func, private_key: RSAPrivateKey, SEPARATOR: bytes = DEFAULT_SEPARATOR, encoding: str = 'utf8') -> bytes:
    """Generator function that takes an iterable of chunks produced.

    :param chunks:
        Iterable of bytes chunks (could be a list or an iterator) generated by the `stream_encrypt_file()` function, to be decoded.
    :param private_key:
        Local private key.
    :param SEPARATOR:
        Separator character or binary sequence used to split the preamble with the symmetric key from the content to be decoded.
        Should be the same used in the `stream_encrypt_file()` function.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        A stream of decoded chunks in bytes format.
    """
    data_array: bytes = bytearray()
    preamble: bool = True
    decryptor = None

    while chunk := next(reader_func):
        if preamble:
            data_array.extend(chunk)

            first_part = bytes(data_array)
            pos = first_part.find(SEPARATOR)

            if pos > 0:
                # recover key
                preamble = False

                preamble_bytes: bytes = first_part[:pos]
                symmetric_key: SymmetricKey = decrypt_hybrid_key(preamble_bytes, private_key, encoding)

                # build decryptor
                decryptor = symmetric_key.decryptor()

                # start decrypt with the rest of the chunk
                yield decryptor.update(first_part[pos+len(SEPARATOR):])

        else:
            if decryptor is None:
                LOGGER.error('could not instantiate decryptor')
                raise ValueError('Preamble decoding failed')

            yield decryptor.update(chunk)

    yield decryptor.finalize()


def decrypt_stream_file(reader_func, path: str, private_key: RSAPrivateKey, SEPARATOR: bytes = DEFAULT_SEPARATOR, encoding: str = 'utf8') -> str:
    """Generator function that takes an iterable of chunks produced.

    :param chunks:
        Iterable of bytes chunks (could be a list or an iterator) generated by the `stream_encrypt_file()` function, to be decoded.
    :param private_key:
        Local private key.
    :param SEPARATOR:
        Separator character or binary sequence used to split the preamble with the symmetric key from the content to be decoded.
        Should be the same used in the `stream_encrypt_file()` function.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        Checksum of decrypted data.
    """
    data_array: bytes = bytearray()
    preamble: bool = True
    decryptor = None

    checksum = sha256()

    with open(path, 'wb') as f:
        while chunk := next(reader_func):
            if preamble:
                data_array.extend(chunk)

                first_part = bytes(data_array)
                pos = first_part.find(SEPARATOR)

                if pos > 0:
                    # recover key
                    preamble = False

                    preamble_bytes: bytes = first_part[:pos]
                    symmetric_key: SymmetricKey = decrypt_hybrid_key(preamble_bytes, private_key, encoding)

                    # build decryptor
                    decryptor = symmetric_key.decryptor()

                    # start decrypt with the rest of the chunk
                    data = decryptor.update(first_part[pos+len(SEPARATOR):])
                    checksum.update(data)
                    f.write(data)

            else:
                if decryptor is None:
                    LOGGER.error('could not instantiate decryptor')
                    raise ValueError('Preamble decoding failed')

                data = decryptor.update(chunk)
                checksum.update(data)
                f.write(data)

        data = decryptor.finalize()
        checksum.update(data)
        f.write(data)

    return checksum.hexdigest()


class HybridDecrypter:

    # TODO: document

    def __init__(self, private_key: RSAPrivateKey, SEPARATOR: bytes = DEFAULT_SEPARATOR, encoding: str = 'utf8') -> None:
        self.private_key: RSAPrivateKey = private_key
        self.SEPARATOR: bytes = SEPARATOR
        self.encoding: str = encoding

        self.decryptor = None
        self.checksum = None

        self.data: bytearray = None
        self.preamble_found: bool = False

    def decrypt(self, content: bytes) -> str:
        output: list[str] = []

        output += self.start()
        output += self.update(content)
        output += self.end()

        return ''.join(output)

    def start(self) -> str:
        self.data = bytearray()
        self.checksum = sha256()
        return ''

    def update(self, content: bytes) -> str:
        if not self.preamble_found:
            self.data.extend(content)

            pos = self.data.find(self.SEPARATOR)

            if pos > 0:
                self.preamble_found = True

                data = bytes(self.data)

                preamble_bytes: bytes = data[:pos]
                symmetric_key: SymmetricKey = decrypt_hybrid_key(preamble_bytes, self.private_key, self.encoding)

                self.decryptor = symmetric_key.decryptor()

                data: bytes = self.decryptor.update(data[pos+len(self.SEPARATOR):])
                self.checksum.update(data)
                return data.decode(self.encoding)

            return ''

        else:
            data: bytes = self.decryptor.update(content)
            self.checksum.update(data)
            return data.decode(self.encoding)

    def end(self) -> str:
        data = self.decryptor.finalize()
        self.checksum.update(data)
        return data.decode(self.encoding)

    def get_checksum(self) -> str:
        return self.checksum.hexdigest()
