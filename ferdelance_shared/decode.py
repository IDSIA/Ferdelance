from .generate import SymmetricKey

from typing import Iterable

from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey

from base64 import b64decode

import json
import logging

LOGGER = logging.getLogger(__name__)


def decode_from_transfer(text: str, encoding: str = 'utf8') -> str:
    """Decode the string received through a transfer between client and server.
    :param text:
        Text to decode.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        Decoded bytes.
    """
    in_bytes: bytes = text.encode(encoding)
    b64_bytes: bytes = b64decode(in_bytes)
    out_text: str = b64_bytes.decode(encoding)
    return out_text


def decrypt(private_key: RSAPrivateKey, text: str, encoding: str = 'utf8') -> str:
    """Decrypt a text using a private key.

    :param private_jey:
        Local private key.
    :param text:
        Content to be decrypted.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        The decoded string.
    """
    b64_text: bytes = text.encode(encoding)
    enc_text: bytes = b64decode(b64_text)
    plain_text: bytes = private_key.decrypt(enc_text, padding.PKCS1v15())
    ret_text: str = plain_text.decode(encoding)
    return ret_text


def decrypt_hybrid_key(preamble: bytes, private_key: RSAPrivateKey, encoding='utf8') -> SymmetricKey:
    """Decodes the preamble of a stream, containing the symmetric key for hybrid encryption.

    :param preamble:
        Content read from the stream.
    :param private_key:
        Local private key.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        The SymmetricKey to use.
    """

    preamble_bytes: bytes = private_key.decrypt(preamble, padding.PKCS1v15())
    preamble_bytes: bytes = b64decode(preamble_bytes)
    preamble_str: str = preamble_bytes.decode('utf8')

    decoded: dict = json.loads(preamble_str)

    return SymmetricKey(
        b64decode(decoded['key'].encode(encoding)),
        b64decode(decoded['iv'].encode(encoding)),
    )


def decrypt_stream(chunks: Iterable, private_key: RSAPrivateKey, SEPARATOR: bytes = b'\n', encoding: str = 'utf8') -> bytes:
    """Generator function that takes an iterable of chunks produced.

    :param chunks:
        Iterable of bytes chunks (could be a list or an iterator) generated by the `stream_encrypt_file()` function, to be decoded.
    :param private_key:
        Local private key.
    :param SEPARATOR:
        Separator character or binary sequence used to split the preable with the symmetric key from the content to be decoded.
        Should be the same used in the `stream_encrypt_file()` function.
    :param encoding:
        Encoding to use in the string-byte conversion.
    :return:
        A stream of decoded chunks in bytes format.
    """
    first_part = []
    preamble = True
    decryptor = None

    for chunk in chunks:
        if chunk == SEPARATOR:
            # recover key
            preamble = False

            preamble_bytes: bytes = b''.join(first_part)
            symmetric_key: SymmetricKey = decrypt_hybrid_key(preamble_bytes, private_key, encoding)

            decryptor = symmetric_key.decryptor()

        elif preamble:
            first_part.append(chunk)

        else:
            assert decryptor is not None
            yield decryptor.update(chunk)

    yield decryptor.finalize()
