from typing import Iterator
from abc import ABC, abstractmethod

from pathlib import Path


class EncryptionAlgorithm(ABC):
    def encrypt(self, content: str | bytes) -> bytes:
        """Encrypt the whole content.

        :param content:
            Data to encrypt.
        :return:
            Encrypted input data in byte format.
        """
        enc_content: bytearray = bytearray()

        enc_content += self.start()
        enc_content += self.update(content)
        enc_content += self.end()

        return bytes(enc_content)

    def encrypt_file_to_stream(self, in_path: Path, CHUNK_SIZE: int = 4096) -> Iterator[bytes]:
        """Generator function that encrypt an input file read from disk.

        :param in_path:
            Path on disk of the file to stream.
        :param CHUNK_SIZE:
            Size in bytes of each chunk transmitted to the client.
        :return:

        """
        yield self.start()

        with open(in_path, "rb") as f:
            while chunk := f.read(CHUNK_SIZE):
                yield self.update(chunk)

        yield self.end()

    def encrypt_content_to_stream(self, content: str | bytes, CHUNK_SIZE: int = 4096) -> Iterator[bytes]:
        """Generator function that streams the given content.

        :param content:
            Content to stream in string format.
        :param CHUNK_SIZE:
            Size in bytes of each chunk transmitted to the client.
        :return:
            A stream of bytes
        """
        yield self.start()

        n = len(content)

        start: int = 0
        end: int = CHUNK_SIZE

        while True:
            chunk = content[start:end]

            if len(chunk) == 0:
                break

            yield self.update(chunk)

            start = end
            end = min(end + CHUNK_SIZE, n)

        yield self.end()

    @abstractmethod
    def start(self) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def update(self, content: str | bytes) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def end(self) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def get_checksum(self) -> str:
        raise NotImplementedError()


class DecryptionAlgorithm(ABC):
    def decrypt(self, content: bytes) -> bytes:
        """Decrypt the whole content.

        :param content:
            Data to decrypt.
        :return:
           Decrypted input data in string format.
        """
        data: bytearray = bytearray()

        data.extend(self.start())
        data.extend(self.update(content))
        data.extend(self.end())

        return bytes(data)

    def decrypt_stream_to_file(self, stream_func: Iterator[bytes], path_out: Path) -> None:
        """Consumer method takes an iterable of chunks produced by an HybridEncryptor object.

        Decrypted data are save to disk at the given location.

        :param out_path:
            Location on disk where to save the decrypted content.
        :param stream_func:
            Iterable of bytes chunks (could be a list or an iterator or a stream) generated by
            the `encrypt_file_to_stream()` or `encrypt_to_stream()` method, to be decoded.
        """
        with open(path_out, "wb") as f:
            data = self.start()
            f.write(data)

            for chunk in stream_func:
                data = self.update(chunk)
                f.write(data)

            data = self.end()
            f.write(data)

    def decrypt_content_stream(self, stream_func: Iterator[bytes]) -> bytes:
        """Consumer method that takes an iterable of chunks produced by an HybridEncryptor object.

        Decrypted data are joined in a single output stored in memory.

        :param stream_func:
            Iterable of bytes chunks (could be a list or an iterator or a stream) generated by
            the `encrypt_file_to_stream()` or `encrypt_to_stream()` method, to be decoded.
        :return:
            Decrypted content received.
        """
        data: bytearray = bytearray()

        data.extend(self.start())

        for chunk in stream_func:
            data.extend(self.update(chunk))

        data.extend(self.end())

        return data

    @abstractmethod
    def start(self) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def update(self, content: bytes) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def end(self) -> bytes:
        raise NotImplementedError()

    @abstractmethod
    def get_checksum(self) -> str:
        raise NotImplementedError()
