from __future__ import annotations

from enum import Enum
from pydantic import BaseModel

from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.preprocessing import LabelEncoder

from .core import GenericModel, Model

import logging
import numpy as np

LOGGER = logging.getLogger(__name__)


class StrategyRandomForestClassifier(str, Enum):

    MERGE = "merge"
    """The trees generated by all clients will be merged in a single RandomForestClassifier"""

    MAJORITY_VOTE = "majority_vote"
    """All the models will be put together and a classification is decided by majority classification between all models."""


class ParametersRandomForestClassifier(BaseModel):
    """
    Class defining all the parameters accepted in training by the model.

    These parameters are default values from scikit-learn.

    For more details, please refer to https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html
    """

    n_estimators: int = 100
    criterion: str = "gini"
    max_depth: int | None = None
    min_samples_split: int = 2
    min_samples_leaf: int = 1
    min_weight_fraction_leaf: float = 0
    max_features: str = "sqrt"
    max_leaf_nodes: int | None = None
    min_impurity_decrease: float = 0
    bootstrap: bool = True
    oob_score: bool = False
    n_jobs: int | None = None
    random_state: int | None = None
    class_weight: str | list[str] | list[dict[str, float]] | None = None
    ccp_alpha: float = 0
    max_samples: int | None = None


class FederatedRandomForestClassifier(GenericModel):
    def __init__(
        self,
        strategy: StrategyRandomForestClassifier | None = None,
        parameters: ParametersRandomForestClassifier = ParametersRandomForestClassifier(),
        load: str | None = None,
    ) -> None:
        super().__init__()

        self.strategy: StrategyRandomForestClassifier | None = strategy
        self.parameters: ParametersRandomForestClassifier = parameters
        self.model: RandomForestClassifier | None = None

        if load:
            self.load(load)

    def train(self, x, y) -> None:
        if self.model is None:
            self.model = RandomForestClassifier(**self.parameters.dict())

        self.model.fit(x, y)

    def aggregate(
        self, strategy_str: str, model_a: RandomForestClassifier | VotingClassifier, model_b: RandomForestClassifier
    ) -> RandomForestClassifier | VotingClassifier:
        LOGGER.info(f"AggregatorRandomForestClassifier: using strategy={strategy_str}")

        strategy = StrategyRandomForestClassifier[strategy_str]

        if strategy == StrategyRandomForestClassifier.MERGE:
            if not isinstance(model_a, RandomForestClassifier):
                raise ValueError(
                    "StrategyRandomForestClassifier.MERGE can be used only with RandomForestClassifier models"
                )

            return self.merge(model_a, model_b)

        if strategy == StrategyRandomForestClassifier.MAJORITY_VOTE:
            return self.majority_vote(model_a, model_b)

        raise ValueError(f"Unsupported strategy: {strategy_str}")

    def merge(self, model_a: RandomForestClassifier, model_b: RandomForestClassifier) -> RandomForestClassifier:
        """Solution adapted from: https://stackoverflow.com/a/28508619/1419058"""
        model_a.estimators_ += model_b.estimators_
        model_a.n_estimators = len(model_a.estimators_)

        return model_a

    def majority_vote(
        self, model_a: RandomForestClassifier | VotingClassifier, model_b: RandomForestClassifier
    ) -> VotingClassifier:
        """Solution adapted from: https://stackoverflow.com/a/54610569/1419058"""

        if isinstance(model_a, VotingClassifier):
            assert model_a.estimators_ is not None

            model_a.estimators_.append((f"{len(model_a.estimators_)}", model_b))
            return model_a

        models = [("0", model_a), ("1", model_b)]
        vc = VotingClassifier(estimators=models, voting="soft")

        vc.estimators_ = models
        vc.le_ = LabelEncoder().fit(model_a.classes_)  # TODO: check if this is valid?
        vc.classes_ = vc.le_.classes_

        return vc

    def predict(self, x) -> np.ndarray:
        if self.model is None:
            raise ValueError("No model has been loaded or created")
        return self.model.predict(x)

    def build(self) -> Model:
        if not self.strategy:
            raise ValueError("Cannot build model with no strategy assigned")

        return Model(
            name=self.__class__.__name__,
            strategy=self.strategy.name,
            parameters=self.parameters.dict(),
        )
